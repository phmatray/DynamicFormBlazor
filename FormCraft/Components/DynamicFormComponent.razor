@*
A dynamic form component that renders forms based on configuration and provides automatic validation.
This component coordinates field rendering, validation, and form submission for type-safe dynamic forms.
*@

@namespace FormCraft
@typeparam TModel where TModel : new()
@inject IFieldRendererService FieldRendererService

<EditForm Model="@Model" OnValidSubmit="@OnSubmit">
    <DataAnnotationsValidator />
    <DynamicFormValidator TModel="TModel" Configuration="@Configuration" />
    
    @if (ShouldUseFieldGroups())
    {
        @* Render fields in groups *@
        @foreach (var group in GetFieldGroups().OrderBy(g => g.Order))
        {
            <div class="@GetGroupContainerClass(group) mb-3">
                @if (group.ShowCard)
                {
                    <MudCard Elevation="@group.CardElevation" Class="mb-4">
                        @if (!string.IsNullOrEmpty(group.Name))
                        {
                            <MudCardHeader>
                                <CardHeaderContent>
                                    <MudText Typo="Typo.h6">@group.Name</MudText>
                                </CardHeaderContent>
                            </MudCardHeader>
                        }
                        <MudCardContent>
                            <MudGrid Spacing="2">
                                @foreach (var fieldName in group.FieldNames)
                                {
                                    var field = Configuration.Fields.FirstOrDefault(f => f.FieldName == fieldName);
                                    if (field != null && ShouldShowField(field))
                                    {
                                        <MudItem xs="@GetColumnWidth(group.Columns)" sm="@GetColumnWidth(group.Columns)" md="@GetColumnWidth(group.Columns)" lg="@GetColumnWidth(group.Columns)">
                                            <div class="form-field-container">
                                                @FieldRendererService.RenderField(Model, field, 
                                                    EventCallback.Factory.Create<object?>(this, value => HandleFieldValueChanged(field.FieldName, value)),
                                                    EventCallback.Factory.Create(this, () => HandleFieldDependencyChanged(field.FieldName)))
                                                <FieldValidationMessage FieldName="@field.FieldName" />
                                            </div>
                                        </MudItem>
                                    }
                                }
                            </MudGrid>
                        </MudCardContent>
                    </MudCard>
                }
                else
                {
                    <MudGrid Spacing="2">
                        @foreach (var fieldName in group.FieldNames)
                        {
                            var field = Configuration.Fields.FirstOrDefault(f => f.FieldName == fieldName);
                            if (field != null && ShouldShowField(field))
                            {
                                <MudItem xs="@GetColumnWidth(group.Columns)" sm="@GetColumnWidth(group.Columns)" md="@GetColumnWidth(group.Columns)" lg="@GetColumnWidth(group.Columns)">
                                    <div class="form-field-container">
                                        @FieldRendererService.RenderField(Model, field, 
                                            EventCallback.Factory.Create<object?>(this, value => HandleFieldValueChanged(field.FieldName, value)),
                                            EventCallback.Factory.Create(this, () => HandleFieldDependencyChanged(field.FieldName)))
                                        <FieldValidationMessage FieldName="@field.FieldName" />
                                    </div>
                                </MudItem>
                            }
                        }
                    </MudGrid>
                }
            </div>
        }
        
        @* Render ungrouped fields *@
        var groupedFieldNames = GetFieldGroups().SelectMany(g => g.FieldNames).ToHashSet();
        var ungroupedFields = Configuration.Fields.Where(f => !groupedFieldNames.Contains(f.FieldName)).OrderBy(f => f.Order).ToList();
        
        if (ungroupedFields.Any())
        {
            <div class="@GetFormLayoutClass()">
                @foreach (var field in ungroupedFields)
                {
                    if (ShouldShowField(field))
                    {
                        <div class="@GetFieldLayoutClass(field) mb-4">
                            <div class="form-field-container">
                                @FieldRendererService.RenderField(Model, field, 
                                    EventCallback.Factory.Create<object?>(this, value => HandleFieldValueChanged(field.FieldName, value)),
                                    EventCallback.Factory.Create(this, () => HandleFieldDependencyChanged(field.FieldName)))
                                <FieldValidationMessage FieldName="@field.FieldName" />
                            </div>
                        </div>
                    }
                }
            </div>
        }
    }
    else
    {
        @* Traditional rendering without groups *@
        <div class="@GetFormLayoutClass()">
            @foreach (var field in Configuration.Fields.OrderBy(f => f.Order))
            {
                @if (ShouldShowField(field))
                {
                    <div class="@GetFieldLayoutClass(field) mb-4">
                        <div class="form-field-container">
                            @FieldRendererService.RenderField(Model, field, 
                                EventCallback.Factory.Create<object?>(this, value => HandleFieldValueChanged(field.FieldName, value)),
                                EventCallback.Factory.Create(this, () => HandleFieldDependencyChanged(field.FieldName)))
                            <FieldValidationMessage FieldName="@field.FieldName" />
                        </div>
                    </div>
                }
            }
        </div>
    }
    
    @if (ShowSubmitButton)
    {
        <MudCardActions Class="justify-center pa-4">
            <MudButton ButtonType="ButtonType.Submit"
                      Variant="Variant.Filled"
                      Color="Color.Primary"
                      Size="Size.Large"
                      Disabled="@IsSubmitting"
                      StartIcon="@(IsSubmitting ? Icons.Material.Filled.HourglassEmpty : Icons.Material.Filled.Send)"
                      Class="@SubmitButtonClass">
                @if (IsSubmitting)
                {
                    <MudProgressCircular Class="me-2" Size="Size.Small" Indeterminate="true" />
                    <span>@SubmittingText</span>
                }
                else
                {
                    <span>@SubmitButtonText</span>
                }
            </MudButton>
        </MudCardActions>
    }
</EditForm>